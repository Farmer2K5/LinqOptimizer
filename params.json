{"name":"LinqOptimizer","tagline":"An automatic query optimizer for LINQ to Objects and PLINQ.","body":"LinqOptimizer\r\n=============\r\nAn automatic query optimizer for LINQ to Objects and PLINQ. \r\nLinqOptimizer compiles declarative LINQ queries into fast loop-based imperative code.\r\nThe compiled code has fewer virtual calls, better data locality and speedups of up to 15x.\r\n\r\nThe main idea is that we lift query sources into the world of Expression trees and\r\nafter various transformations-optimizations we compile them into IL for efficient execution.\r\n\r\n```csharp\r\nvar query = (from num in nums.AsQueryExpr() // lift\r\n             where num % 2 == 0\r\n             select num * num).Sum();\r\n             \r\nConsole.WriteLine(\"Result: {0}\", query.Run()); // compile and execute\r\n```\r\n\r\nFor F# we support functional pipelines and support for F# style LINQ queries is in development.\r\n```fsharp\r\nlet query = nums\r\n            |> Query.ofSeq\r\n            |> Query.filter (fun num -> num % 2 = 0)\r\n            |> Query.map (fun num -> num * num)\r\n            |> Query.sum\r\n             \r\nprintfn \"Result: %d\" <| Query.run query // compile and execute\r\n```\r\n\r\nOptimizations\r\n-----------------------\r\n* Lambda inlining\r\n* Loop fusion\r\n* Nested loop generation\r\n* Specialized strategies and algorithms\r\n\r\nThe expression\r\n```csharp\r\nvar query = (from num in nums.AsQueryExpr()\r\n             where num % 2 == 0\r\n             select num * num).Sum();\r\n```\r\nwill compile to\r\n```csharp\r\nint sum = 0;\r\nfor (int index = 0; index < nums.Length; index++)\r\n{\r\n   int num = nums[index];\r\n   if (num % 2 == 0)\r\n      sum += num * num;\r\n}\r\n```\r\nand for the parallel case\r\n```csharp\r\nvar query = (from num in nums.AsParallelQueryExpr()\r\n             where num % 2 == 0\r\n             select num * num).Sum();\r\n```\r\nwill compile to a reduce-combine style straregy\r\n```csharp\r\nParallel.ReduceCombine(nums, 0, \r\n                          (acc, num) => { \r\n                                       if (num % 2 == 0)  \r\n                                         return acc + num * num; \r\n                                       else\r\n                                         return acc; \r\n                          }, (left, right) => left + right);\r\n```\r\n\r\nFuture work\r\n-----------\r\n* Many missing operators\r\n* New specialized operators \r\n* Even more optimizations\r\n* GPU backend\r\n* DistributedLinq (Combining LinqOptimizer with [MBrace](http://www.m-brace.net))\r\n\r\nReferences\r\n----------\r\nLinqOptimizer draws heavy inspiration from \r\n* [Steno](http://research.microsoft.com/pubs/173946/paper-pldi.pdf)\r\n* [Clojure - reducers](http://clojure.org/reducers)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}